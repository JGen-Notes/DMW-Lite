/*
 * generated by Xtext 2.12.0
 */
package eu.jgen.notes.dmw.lite.serializer;

import com.google.inject.Inject;
import eu.jgen.notes.dmw.lite.lang.LangPackage;
import eu.jgen.notes.dmw.lite.lang.YAndExpression;
import eu.jgen.notes.dmw.lite.lang.YAnnot;
import eu.jgen.notes.dmw.lite.lang.YAnnotAbstractColumn;
import eu.jgen.notes.dmw.lite.lang.YAnnotAction;
import eu.jgen.notes.dmw.lite.lang.YAnnotAttr;
import eu.jgen.notes.dmw.lite.lang.YAnnotColumn;
import eu.jgen.notes.dmw.lite.lang.YAnnotColumnLike;
import eu.jgen.notes.dmw.lite.lang.YAnnotDatabase;
import eu.jgen.notes.dmw.lite.lang.YAnnotDecimal;
import eu.jgen.notes.dmw.lite.lang.YAnnotDefault;
import eu.jgen.notes.dmw.lite.lang.YAnnotDefaultNumber;
import eu.jgen.notes.dmw.lite.lang.YAnnotDefaultText;
import eu.jgen.notes.dmw.lite.lang.YAnnotEntity;
import eu.jgen.notes.dmw.lite.lang.YAnnotForeignKey;
import eu.jgen.notes.dmw.lite.lang.YAnnotId;
import eu.jgen.notes.dmw.lite.lang.YAnnotJava;
import eu.jgen.notes.dmw.lite.lang.YAnnotLength;
import eu.jgen.notes.dmw.lite.lang.YAnnotMax;
import eu.jgen.notes.dmw.lite.lang.YAnnotMessage;
import eu.jgen.notes.dmw.lite.lang.YAnnotPrimaryKey;
import eu.jgen.notes.dmw.lite.lang.YAnnotRel;
import eu.jgen.notes.dmw.lite.lang.YAnnotSwift;
import eu.jgen.notes.dmw.lite.lang.YAnnotTable;
import eu.jgen.notes.dmw.lite.lang.YAnnotTechnicalDesign;
import eu.jgen.notes.dmw.lite.lang.YAnnotTop;
import eu.jgen.notes.dmw.lite.lang.YArgument;
import eu.jgen.notes.dmw.lite.lang.YAssignment;
import eu.jgen.notes.dmw.lite.lang.YAssociateStatement;
import eu.jgen.notes.dmw.lite.lang.YBlock;
import eu.jgen.notes.dmw.lite.lang.YBoolConstant;
import eu.jgen.notes.dmw.lite.lang.YClass;
import eu.jgen.notes.dmw.lite.lang.YComparisonExpression;
import eu.jgen.notes.dmw.lite.lang.YCreateStatement;
import eu.jgen.notes.dmw.lite.lang.YDeleteStatement;
import eu.jgen.notes.dmw.lite.lang.YEqualityExpression;
import eu.jgen.notes.dmw.lite.lang.YForInStatement;
import eu.jgen.notes.dmw.lite.lang.YFunction;
import eu.jgen.notes.dmw.lite.lang.YIfStatement;
import eu.jgen.notes.dmw.lite.lang.YImport;
import eu.jgen.notes.dmw.lite.lang.YIntConstant;
import eu.jgen.notes.dmw.lite.lang.YJoin;
import eu.jgen.notes.dmw.lite.lang.YJoinDef;
import eu.jgen.notes.dmw.lite.lang.YMemberSelection;
import eu.jgen.notes.dmw.lite.lang.YMinus;
import eu.jgen.notes.dmw.lite.lang.YMulOrDiv;
import eu.jgen.notes.dmw.lite.lang.YNew;
import eu.jgen.notes.dmw.lite.lang.YNot;
import eu.jgen.notes.dmw.lite.lang.YNull;
import eu.jgen.notes.dmw.lite.lang.YOrExpression;
import eu.jgen.notes.dmw.lite.lang.YParameter;
import eu.jgen.notes.dmw.lite.lang.YParenties;
import eu.jgen.notes.dmw.lite.lang.YPlus;
import eu.jgen.notes.dmw.lite.lang.YProperty;
import eu.jgen.notes.dmw.lite.lang.YReadEachStatement;
import eu.jgen.notes.dmw.lite.lang.YReadStatement;
import eu.jgen.notes.dmw.lite.lang.YRepeatWhileStatement;
import eu.jgen.notes.dmw.lite.lang.YReturn;
import eu.jgen.notes.dmw.lite.lang.YSelf;
import eu.jgen.notes.dmw.lite.lang.YStringConstant;
import eu.jgen.notes.dmw.lite.lang.YStructRefPair;
import eu.jgen.notes.dmw.lite.lang.YSuper;
import eu.jgen.notes.dmw.lite.lang.YSwitchCase;
import eu.jgen.notes.dmw.lite.lang.YSwitchStatement;
import eu.jgen.notes.dmw.lite.lang.YSymbolRef;
import eu.jgen.notes.dmw.lite.lang.YTuples;
import eu.jgen.notes.dmw.lite.lang.YUpdateStatement;
import eu.jgen.notes.dmw.lite.lang.YVariableDeclaration;
import eu.jgen.notes.dmw.lite.lang.YWhere;
import eu.jgen.notes.dmw.lite.lang.YWhileStatement;
import eu.jgen.notes.dmw.lite.lang.YWidget;
import eu.jgen.notes.dmw.lite.services.LangGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class LangSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private LangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == LangPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case LangPackage.YAND_EXPRESSION:
				sequence_YAndExpression(context, (YAndExpression) semanticObject); 
				return; 
			case LangPackage.YANNOT:
				if (rule == grammarAccess.getYAnnotMsgTypeRule()) {
					sequence_YAnnotMsgType(context, (YAnnot) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getYAnnotRule()) {
					sequence_YAnnot(context, (YAnnot) semanticObject); 
					return; 
				}
				else break;
			case LangPackage.YANNOT_ABSTRACT_COLUMN:
				sequence_YAnnotAbstractColumn(context, (YAnnotAbstractColumn) semanticObject); 
				return; 
			case LangPackage.YANNOT_ACTION:
				sequence_YAnnotAction(context, (YAnnotAction) semanticObject); 
				return; 
			case LangPackage.YANNOT_ATTR:
				sequence_YAnnotAttr(context, (YAnnotAttr) semanticObject); 
				return; 
			case LangPackage.YANNOT_COLUMN:
				sequence_YAnnotColumn(context, (YAnnotColumn) semanticObject); 
				return; 
			case LangPackage.YANNOT_COLUMN_LIKE:
				sequence_YAnnotColumnLike(context, (YAnnotColumnLike) semanticObject); 
				return; 
			case LangPackage.YANNOT_DATABASE:
				sequence_YAnnotDatabase(context, (YAnnotDatabase) semanticObject); 
				return; 
			case LangPackage.YANNOT_DECIMAL:
				sequence_YAnnotDecimal(context, (YAnnotDecimal) semanticObject); 
				return; 
			case LangPackage.YANNOT_DEFAULT:
				sequence_YAnnotDefault(context, (YAnnotDefault) semanticObject); 
				return; 
			case LangPackage.YANNOT_DEFAULT_NUMBER:
				sequence_YAnnotDefaultNumber(context, (YAnnotDefaultNumber) semanticObject); 
				return; 
			case LangPackage.YANNOT_DEFAULT_TEXT:
				sequence_YAnnotDefaultText(context, (YAnnotDefaultText) semanticObject); 
				return; 
			case LangPackage.YANNOT_ENTITY:
				sequence_YAnnotEntity(context, (YAnnotEntity) semanticObject); 
				return; 
			case LangPackage.YANNOT_FOREIGN_KEY:
				sequence_YAnnotForeignKey(context, (YAnnotForeignKey) semanticObject); 
				return; 
			case LangPackage.YANNOT_ID:
				sequence_YAnnotId(context, (YAnnotId) semanticObject); 
				return; 
			case LangPackage.YANNOT_JAVA:
				sequence_YAnnotJava(context, (YAnnotJava) semanticObject); 
				return; 
			case LangPackage.YANNOT_LENGTH:
				sequence_YAnnotLength(context, (YAnnotLength) semanticObject); 
				return; 
			case LangPackage.YANNOT_MAX:
				sequence_YAnnotMax(context, (YAnnotMax) semanticObject); 
				return; 
			case LangPackage.YANNOT_MESSAGE:
				sequence_YAnnotMessage(context, (YAnnotMessage) semanticObject); 
				return; 
			case LangPackage.YANNOT_PRIMARY_KEY:
				sequence_YAnnotPrimaryKey(context, (YAnnotPrimaryKey) semanticObject); 
				return; 
			case LangPackage.YANNOT_REL:
				sequence_YAnnotRel(context, (YAnnotRel) semanticObject); 
				return; 
			case LangPackage.YANNOT_SWIFT:
				sequence_YAnnotSwift(context, (YAnnotSwift) semanticObject); 
				return; 
			case LangPackage.YANNOT_TABLE:
				sequence_YAnnotTable(context, (YAnnotTable) semanticObject); 
				return; 
			case LangPackage.YANNOT_TECHNICAL_DESIGN:
				sequence_YAnnotTechnicalDesign(context, (YAnnotTechnicalDesign) semanticObject); 
				return; 
			case LangPackage.YANNOT_TOP:
				sequence_YAnnotTop(context, (YAnnotTop) semanticObject); 
				return; 
			case LangPackage.YARGUMENT:
				sequence_YArgument(context, (YArgument) semanticObject); 
				return; 
			case LangPackage.YASSIGNMENT:
				sequence_YAssignment(context, (YAssignment) semanticObject); 
				return; 
			case LangPackage.YASSOCIATE_STATEMENT:
				sequence_YAssociateStatement(context, (YAssociateStatement) semanticObject); 
				return; 
			case LangPackage.YBLOCK:
				sequence_YBlock(context, (YBlock) semanticObject); 
				return; 
			case LangPackage.YBOOL_CONSTANT:
				sequence_YTerminalExpression(context, (YBoolConstant) semanticObject); 
				return; 
			case LangPackage.YCLASS:
				sequence_YClass(context, (YClass) semanticObject); 
				return; 
			case LangPackage.YCOMPARISON_EXPRESSION:
				sequence_YComparisonExpression(context, (YComparisonExpression) semanticObject); 
				return; 
			case LangPackage.YCREATE_STATEMENT:
				sequence_YCreateStatement(context, (YCreateStatement) semanticObject); 
				return; 
			case LangPackage.YDELETE_STATEMENT:
				sequence_YDeleteStatement(context, (YDeleteStatement) semanticObject); 
				return; 
			case LangPackage.YEQUALITY_EXPRESSION:
				sequence_YEqualityExpression(context, (YEqualityExpression) semanticObject); 
				return; 
			case LangPackage.YFOR_IN_STATEMENT:
				sequence_YForInStatement(context, (YForInStatement) semanticObject); 
				return; 
			case LangPackage.YFUNCTION:
				sequence_YFunction(context, (YFunction) semanticObject); 
				return; 
			case LangPackage.YIF_STATEMENT:
				sequence_YIfStatement(context, (YIfStatement) semanticObject); 
				return; 
			case LangPackage.YIMPORT:
				sequence_YImport(context, (YImport) semanticObject); 
				return; 
			case LangPackage.YINT_CONSTANT:
				sequence_YTerminalExpression(context, (YIntConstant) semanticObject); 
				return; 
			case LangPackage.YJOIN:
				sequence_YJoin(context, (YJoin) semanticObject); 
				return; 
			case LangPackage.YJOIN_DEF:
				sequence_YJoinDef(context, (YJoinDef) semanticObject); 
				return; 
			case LangPackage.YMEMBER_SELECTION:
				sequence_YSelectionExpression(context, (YMemberSelection) semanticObject); 
				return; 
			case LangPackage.YMINUS:
				sequence_YAdditiveExpression(context, (YMinus) semanticObject); 
				return; 
			case LangPackage.YMUL_OR_DIV:
				sequence_YMultiplicativeExpression(context, (YMulOrDiv) semanticObject); 
				return; 
			case LangPackage.YNEW:
				sequence_YTerminalExpression(context, (YNew) semanticObject); 
				return; 
			case LangPackage.YNOT:
				sequence_YPrimary(context, (YNot) semanticObject); 
				return; 
			case LangPackage.YNULL:
				sequence_YTerminalExpression(context, (YNull) semanticObject); 
				return; 
			case LangPackage.YOR_EXPRESSION:
				sequence_YOrExpression(context, (YOrExpression) semanticObject); 
				return; 
			case LangPackage.YPARAMETER:
				sequence_YTypedDeclaration(context, (YParameter) semanticObject); 
				return; 
			case LangPackage.YPARENTIES:
				sequence_YPrimary(context, (YParenties) semanticObject); 
				return; 
			case LangPackage.YPLUS:
				sequence_YAdditiveExpression(context, (YPlus) semanticObject); 
				return; 
			case LangPackage.YPROPERTY:
				sequence_YProperty_YTypedDeclaration(context, (YProperty) semanticObject); 
				return; 
			case LangPackage.YREAD_EACH_STATEMENT:
				sequence_YReadEachStatement(context, (YReadEachStatement) semanticObject); 
				return; 
			case LangPackage.YREAD_STATEMENT:
				sequence_YReadStatement(context, (YReadStatement) semanticObject); 
				return; 
			case LangPackage.YREPEAT_WHILE_STATEMENT:
				sequence_YRepeatWhileStatement(context, (YRepeatWhileStatement) semanticObject); 
				return; 
			case LangPackage.YRETURN:
				sequence_YReturn(context, (YReturn) semanticObject); 
				return; 
			case LangPackage.YSELF:
				sequence_YTerminalExpression(context, (YSelf) semanticObject); 
				return; 
			case LangPackage.YSTRING_CONSTANT:
				sequence_YTerminalExpression(context, (YStringConstant) semanticObject); 
				return; 
			case LangPackage.YSTRUCT_REF_PAIR:
				sequence_YStructRefPair(context, (YStructRefPair) semanticObject); 
				return; 
			case LangPackage.YSUPER:
				sequence_YTerminalExpression(context, (YSuper) semanticObject); 
				return; 
			case LangPackage.YSWITCH_CASE:
				sequence_YSwitchCase(context, (YSwitchCase) semanticObject); 
				return; 
			case LangPackage.YSWITCH_STATEMENT:
				sequence_YSwitchStatement(context, (YSwitchStatement) semanticObject); 
				return; 
			case LangPackage.YSYMBOL_REF:
				sequence_YTerminalExpression(context, (YSymbolRef) semanticObject); 
				return; 
			case LangPackage.YTUPLES:
				sequence_YTuples(context, (YTuples) semanticObject); 
				return; 
			case LangPackage.YUPDATE_STATEMENT:
				sequence_YUpdateStatement(context, (YUpdateStatement) semanticObject); 
				return; 
			case LangPackage.YVARIABLE_DECLARATION:
				sequence_YTypedDeclaration_YVariableDeclaration(context, (YVariableDeclaration) semanticObject); 
				return; 
			case LangPackage.YWHERE:
				sequence_YWhere(context, (YWhere) semanticObject); 
				return; 
			case LangPackage.YWHILE_STATEMENT:
				sequence_YWhileStatement(context, (YWhileStatement) semanticObject); 
				return; 
			case LangPackage.YWIDGET:
				sequence_YWidget(context, (YWidget) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     YOrExpression returns YMinus
	 *     YOrExpression.YOrExpression_1_0 returns YMinus
	 *     YAndExpression returns YMinus
	 *     YAndExpression.YAndExpression_1_0 returns YMinus
	 *     YEqualityExpression returns YMinus
	 *     YEqualityExpression.YEqualityExpression_1_0 returns YMinus
	 *     YComparisonExpression returns YMinus
	 *     YComparisonExpression.YComparisonExpression_1_0 returns YMinus
	 *     YAdditiveExpression returns YMinus
	 *     YAdditiveExpression.YPlus_1_0_0_0 returns YMinus
	 *     YAdditiveExpression.YMinus_1_0_1_0 returns YMinus
	 *
	 * Constraint:
	 *     (left=YAdditiveExpression_YMinus_1_0_1_0 right=YMultiplicativeExpression)
	 */
	protected void sequence_YAdditiveExpression(ISerializationContext context, YMinus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YMINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YMINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YMINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YMINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYAdditiveExpressionAccess().getYMinusLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getYAdditiveExpressionAccess().getRightYMultiplicativeExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YOrExpression returns YPlus
	 *     YOrExpression.YOrExpression_1_0 returns YPlus
	 *     YAndExpression returns YPlus
	 *     YAndExpression.YAndExpression_1_0 returns YPlus
	 *     YEqualityExpression returns YPlus
	 *     YEqualityExpression.YEqualityExpression_1_0 returns YPlus
	 *     YComparisonExpression returns YPlus
	 *     YComparisonExpression.YComparisonExpression_1_0 returns YPlus
	 *     YAdditiveExpression returns YPlus
	 *     YAdditiveExpression.YPlus_1_0_0_0 returns YPlus
	 *     YAdditiveExpression.YMinus_1_0_1_0 returns YPlus
	 *
	 * Constraint:
	 *     (left=YAdditiveExpression_YPlus_1_0_0_0 right=YMultiplicativeExpression)
	 */
	protected void sequence_YAdditiveExpression(ISerializationContext context, YPlus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YPLUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YPLUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YPLUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YPLUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYAdditiveExpressionAccess().getYPlusLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getYAdditiveExpressionAccess().getRightYMultiplicativeExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YOrExpression returns YAndExpression
	 *     YOrExpression.YOrExpression_1_0 returns YAndExpression
	 *     YAndExpression returns YAndExpression
	 *     YAndExpression.YAndExpression_1_0 returns YAndExpression
	 *
	 * Constraint:
	 *     (left=YAndExpression_YAndExpression_1_0 right=YEqualityExpression)
	 */
	protected void sequence_YAndExpression(ISerializationContext context, YAndExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YAND_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YAND_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YAND_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YAND_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYAndExpressionAccess().getYAndExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getYAndExpressionAccess().getRightYEqualityExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YAnnotAbstractColumn returns YAnnotAbstractColumn
	 *
	 * Constraint:
	 *     (name=ValidID (type=YAnnotColumn | type=YAnnotColumnLike))
	 */
	protected void sequence_YAnnotAbstractColumn(ISerializationContext context, YAnnotAbstractColumn semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YAnnotAction returns YAnnotAction
	 *
	 * Constraint:
	 *     action=ValidID
	 */
	protected void sequence_YAnnotAction(ISerializationContext context, YAnnotAction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YANNOT_ACTION__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YANNOT_ACTION__ACTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYAnnotActionAccess().getActionValidIDParserRuleCall_3_0(), semanticObject.getAction());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YAnnotEntityInner returns YAnnotAttr
	 *     YAnnotAttr returns YAnnotAttr
	 *     YAnnotIdInner returns YAnnotAttr
	 *
	 * Constraint:
	 *     (name=ValidID yclass=[YClass|QualifiedName] optional='?'? annots+=YAnnot*)
	 */
	protected void sequence_YAnnotAttr(ISerializationContext context, YAnnotAttr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YAnnotColumnLike returns YAnnotColumnLike
	 *
	 * Constraint:
	 *     columnref=[YAnnotAbstractColumn|QualifiedName]
	 */
	protected void sequence_YAnnotColumnLike(ISerializationContext context, YAnnotColumnLike semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YANNOT_COLUMN_LIKE__COLUMNREF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YANNOT_COLUMN_LIKE__COLUMNREF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYAnnotColumnLikeAccess().getColumnrefYAnnotAbstractColumnQualifiedNameParserRuleCall_2_0_1(), semanticObject.eGet(LangPackage.Literals.YANNOT_COLUMN_LIKE__COLUMNREF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YAnnotColumn returns YAnnotColumn
	 *
	 * Constraint:
	 *     (
	 *         attrref=[YAnnotAttr|QualifiedName] 
	 *         (
	 *             type='VARCHAR' | 
	 *             type='CHAR' | 
	 *             type='INTEGER' | 
	 *             type='BIGINT' | 
	 *             type='SMALLINT' | 
	 *             type='DECIMAL' | 
	 *             type='TIME' | 
	 *             type='DATE' | 
	 *             type='TIMESTAMP' | 
	 *             type='BOOLEAN'
	 *         ) 
	 *         optional='?'? 
	 *         annots+=YAnnotLength? 
	 *         (annots+=YAnnotDecimal? annots+=YAnnotLength?)*
	 *     )
	 */
	protected void sequence_YAnnotColumn(ISerializationContext context, YAnnotColumn semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YAnnotDatabase returns YAnnotDatabase
	 *
	 * Constraint:
	 *     name=ValidID
	 */
	protected void sequence_YAnnotDatabase(ISerializationContext context, YAnnotDatabase semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YANNOT_DATABASE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YANNOT_DATABASE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYAnnotDatabaseAccess().getNameValidIDParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YAnnotDecimal returns YAnnotDecimal
	 *
	 * Constraint:
	 *     (length=INT decimal=INT)
	 */
	protected void sequence_YAnnotDecimal(ISerializationContext context, YAnnotDecimal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YANNOT_DECIMAL__LENGTH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YANNOT_DECIMAL__LENGTH));
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YANNOT_DECIMAL__DECIMAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YANNOT_DECIMAL__DECIMAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYAnnotDecimalAccess().getLengthINTTerminalRuleCall_3_0(), semanticObject.getLength());
		feeder.accept(grammarAccess.getYAnnotDecimalAccess().getDecimalINTTerminalRuleCall_5_0(), semanticObject.getDecimal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YAnnotDefaultType returns YAnnotDefaultNumber
	 *     YAnnotDefaultNumber returns YAnnotDefaultNumber
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_YAnnotDefaultNumber(ISerializationContext context, YAnnotDefaultNumber semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YANNOT_DEFAULT_NUMBER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YANNOT_DEFAULT_NUMBER__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYAnnotDefaultNumberAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YAnnotDefaultType returns YAnnotDefaultText
	 *     YAnnotDefaultText returns YAnnotDefaultText
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_YAnnotDefaultText(ISerializationContext context, YAnnotDefaultText semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YANNOT_DEFAULT_TEXT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YANNOT_DEFAULT_TEXT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYAnnotDefaultTextAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YAnnotDefault returns YAnnotDefault
	 *
	 * Constraint:
	 *     type=YAnnotDefaultType
	 */
	protected void sequence_YAnnotDefault(ISerializationContext context, YAnnotDefault semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YANNOT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YANNOT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYAnnotDefaultAccess().getTypeYAnnotDefaultTypeParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YAnnotEntity returns YAnnotEntity
	 *
	 * Constraint:
	 *     (name=ValidID superannot=[YAnnotEntity|QualifiedName]? annots+=YAnnotEntityInner*)
	 */
	protected void sequence_YAnnotEntity(ISerializationContext context, YAnnotEntity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YAnnotForeignKey returns YAnnotForeignKey
	 *
	 * Constraint:
	 *     (relationship=[YAnnotRel|QualifiedName] columns+=YAnnotAbstractColumn columns+=YAnnotAbstractColumn*)
	 */
	protected void sequence_YAnnotForeignKey(ISerializationContext context, YAnnotForeignKey semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YAnnotEntityInner returns YAnnotId
	 *     YAnnotId returns YAnnotId
	 *
	 * Constraint:
	 *     (name=ValidID annots+=[YAnnotEntityInner|ID] annots+=[YAnnotEntityInner|ID]*)
	 */
	protected void sequence_YAnnotId(ISerializationContext context, YAnnotId semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YAnnotJava returns YAnnotJava
	 *
	 * Constraint:
	 *     database=[YAnnotDatabase|ID]?
	 */
	protected void sequence_YAnnotJava(ISerializationContext context, YAnnotJava semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YAnnotLength returns YAnnotLength
	 *
	 * Constraint:
	 *     length=INT
	 */
	protected void sequence_YAnnotLength(ISerializationContext context, YAnnotLength semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YANNOT_LENGTH__LENGTH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YANNOT_LENGTH__LENGTH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYAnnotLengthAccess().getLengthINTTerminalRuleCall_3_0(), semanticObject.getLength());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YAnnotMax returns YAnnotMax
	 *
	 * Constraint:
	 *     length=INT
	 */
	protected void sequence_YAnnotMax(ISerializationContext context, YAnnotMax semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YANNOT_MAX__LENGTH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YANNOT_MAX__LENGTH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYAnnotMaxAccess().getLengthINTTerminalRuleCall_3_0(), semanticObject.getLength());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YAnnotMessage returns YAnnotMessage
	 *
	 * Constraint:
	 *     msg=STRING
	 */
	protected void sequence_YAnnotMessage(ISerializationContext context, YAnnotMessage semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YANNOT_MESSAGE__MSG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YANNOT_MESSAGE__MSG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYAnnotMessageAccess().getMsgSTRINGTerminalRuleCall_3_0(), semanticObject.getMsg());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YAnnotMsgType returns YAnnot
	 *
	 * Constraint:
	 *     msgtype=ValidID
	 */
	protected void sequence_YAnnotMsgType(ISerializationContext context, YAnnot semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YANNOT__MSGTYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YANNOT__MSGTYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYAnnotMsgTypeAccess().getMsgtypeValidIDParserRuleCall_2_0(), semanticObject.getMsgtype());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YAnnotPrimaryKey returns YAnnotPrimaryKey
	 *
	 * Constraint:
	 *     (columns+=[YAnnotAbstractColumn|ID]* columns+=[YAnnotAbstractColumn|ID]*)
	 */
	protected void sequence_YAnnotPrimaryKey(ISerializationContext context, YAnnotPrimaryKey semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YAnnotEntityInner returns YAnnotRel
	 *     YAnnotRel returns YAnnotRel
	 *     YAnnotIdInner returns YAnnotRel
	 *
	 * Constraint:
	 *     (
	 *         parent?='@parent'? 
	 *         name=ValidID 
	 *         optional?='?'? 
	 *         target=[YAnnotEntity|QualifiedName] 
	 *         many?='*'? 
	 *         inverse=[YAnnotRel|QualifiedName]?
	 *     )
	 */
	protected void sequence_YAnnotRel(ISerializationContext context, YAnnotRel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YAnnotSwift returns YAnnotSwift
	 *
	 * Constraint:
	 *     (name=ValidID database=[YAnnotDatabase|ID]?)
	 */
	protected void sequence_YAnnotSwift(ISerializationContext context, YAnnotSwift semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YAnnotTable returns YAnnotTable
	 *
	 * Constraint:
	 *     (name=ValidID entityref=[YAnnotEntity|QualifiedName] columns+=YAnnotAbstractColumn* primarykey=YAnnotPrimaryKey? foreignkeys+=YAnnotForeignKey*)
	 */
	protected void sequence_YAnnotTable(ISerializationContext context, YAnnotTable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YAnnotTechnicalDesign returns YAnnotTechnicalDesign
	 *
	 * Constraint:
	 *     (database=[YAnnotDatabase|ID] features+=YAnnotTable*)
	 */
	protected void sequence_YAnnotTechnicalDesign(ISerializationContext context, YAnnotTechnicalDesign semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YAnnotTop returns YAnnotTop
	 *
	 * Constraint:
	 *     (type=YAnnotEntity | type=YAnnotTechnicalDesign | type=YAnnotSwift | type=YAnnotJava | type=YAnnotDatabase)
	 */
	protected void sequence_YAnnotTop(ISerializationContext context, YAnnotTop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YAnnot returns YAnnot
	 *
	 * Constraint:
	 *     (
	 *         type=YAnnotLength | 
	 *         type=YAnnotDecimal | 
	 *         type=YAnnotAction | 
	 *         type=YAnnotMessage | 
	 *         type=YAnnotMsgType | 
	 *         type=YAnnotDefault | 
	 *         type=YAnnotMax
	 *     )
	 */
	protected void sequence_YAnnot(ISerializationContext context, YAnnot semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YArgument returns YArgument
	 *
	 * Constraint:
	 *     (name=ValidID value=YArgumentValue)
	 */
	protected void sequence_YArgument(ISerializationContext context, YArgument semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YARGUMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YARGUMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YARGUMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YARGUMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYArgumentAccess().getNameValidIDParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getYArgumentAccess().getValueYArgumentValueParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YStatement returns YAssignment
	 *     YExpression returns YAssignment
	 *     YAssignment returns YAssignment
	 *
	 * Constraint:
	 *     (left=YAssignment_YAssignment_1_0 right=YOrExpression)
	 */
	protected void sequence_YAssignment(ISerializationContext context, YAssignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YASSIGNMENT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YASSIGNMENT__LEFT));
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YASSIGNMENT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YASSIGNMENT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYAssignmentAccess().getYAssignmentLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getYAssignmentAccess().getRightYOrExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YStatement returns YAssociateStatement
	 *     YAssociateStatement returns YAssociateStatement
	 *
	 * Constraint:
	 *     joinref=YJoinDef
	 */
	protected void sequence_YAssociateStatement(ISerializationContext context, YAssociateStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YASSOCIATE_STATEMENT__JOINREF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YASSOCIATE_STATEMENT__JOINREF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYAssociateStatementAccess().getJoinrefYJoinDefParserRuleCall_1_0(), semanticObject.getJoinref());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YBlock returns YBlock
	 *
	 * Constraint:
	 *     statements+=YStatement*
	 */
	protected void sequence_YBlock(ISerializationContext context, YBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YClass returns YClass
	 *     YNamedElement returns YClass
	 *
	 * Constraint:
	 *     (name=ValidID superclass=[YClass|QualifiedName]? entityRef=[YAnnotEntity|QualifiedName]? inners+=YClass* members+=YMember*)
	 */
	protected void sequence_YClass(ISerializationContext context, YClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YOrExpression returns YComparisonExpression
	 *     YOrExpression.YOrExpression_1_0 returns YComparisonExpression
	 *     YAndExpression returns YComparisonExpression
	 *     YAndExpression.YAndExpression_1_0 returns YComparisonExpression
	 *     YEqualityExpression returns YComparisonExpression
	 *     YEqualityExpression.YEqualityExpression_1_0 returns YComparisonExpression
	 *     YComparisonExpression returns YComparisonExpression
	 *     YComparisonExpression.YComparisonExpression_1_0 returns YComparisonExpression
	 *
	 * Constraint:
	 *     (left=YComparisonExpression_YComparisonExpression_1_0 op=OpCompare right=YAdditiveExpression)
	 */
	protected void sequence_YComparisonExpression(ISerializationContext context, YComparisonExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YCOMPARISON_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YCOMPARISON_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YCOMPARISON_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YCOMPARISON_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YCOMPARISON_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YCOMPARISON_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYComparisonExpressionAccess().getYComparisonExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getYComparisonExpressionAccess().getOpOpCompareParserRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getYComparisonExpressionAccess().getRightYAdditiveExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YStatement returns YCreateStatement
	 *     YCreateStatement returns YCreateStatement
	 *
	 * Constraint:
	 *     (struct=YStructRefPair setBlock=YBlock success=YBlock alreadyExist=YBlock)
	 */
	protected void sequence_YCreateStatement(ISerializationContext context, YCreateStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YCREATE_STATEMENT__STRUCT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YCREATE_STATEMENT__STRUCT));
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YCREATE_STATEMENT__SET_BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YCREATE_STATEMENT__SET_BLOCK));
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YCREATE_STATEMENT__SUCCESS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YCREATE_STATEMENT__SUCCESS));
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YCREATE_STATEMENT__ALREADY_EXIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YCREATE_STATEMENT__ALREADY_EXIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYCreateStatementAccess().getStructYStructRefPairParserRuleCall_1_0(), semanticObject.getStruct());
		feeder.accept(grammarAccess.getYCreateStatementAccess().getSetBlockYBlockParserRuleCall_2_0(), semanticObject.getSetBlock());
		feeder.accept(grammarAccess.getYCreateStatementAccess().getSuccessYBlockParserRuleCall_4_0(), semanticObject.getSuccess());
		feeder.accept(grammarAccess.getYCreateStatementAccess().getAlreadyExistYBlockParserRuleCall_7_0(), semanticObject.getAlreadyExist());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YStatement returns YDeleteStatement
	 *     YDeleteStatement returns YDeleteStatement
	 *
	 * Constraint:
	 *     struct=YStructRefPair
	 */
	protected void sequence_YDeleteStatement(ISerializationContext context, YDeleteStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YDELETE_STATEMENT__STRUCT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YDELETE_STATEMENT__STRUCT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYDeleteStatementAccess().getStructYStructRefPairParserRuleCall_1_0(), semanticObject.getStruct());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YOrExpression returns YEqualityExpression
	 *     YOrExpression.YOrExpression_1_0 returns YEqualityExpression
	 *     YAndExpression returns YEqualityExpression
	 *     YAndExpression.YAndExpression_1_0 returns YEqualityExpression
	 *     YEqualityExpression returns YEqualityExpression
	 *     YEqualityExpression.YEqualityExpression_1_0 returns YEqualityExpression
	 *
	 * Constraint:
	 *     (left=YEqualityExpression_YEqualityExpression_1_0 (op='==' | op='!=') right=YComparisonExpression)
	 */
	protected void sequence_YEqualityExpression(ISerializationContext context, YEqualityExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YStatement returns YForInStatement
	 *     YForInStatement returns YForInStatement
	 *
	 * Constraint:
	 *     (item=[YProperty|ID] collection=[YProperty|ID] body=YBlock)
	 */
	protected void sequence_YForInStatement(ISerializationContext context, YForInStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YFOR_IN_STATEMENT__ITEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YFOR_IN_STATEMENT__ITEM));
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YFOR_IN_STATEMENT__COLLECTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YFOR_IN_STATEMENT__COLLECTION));
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YFOR_IN_STATEMENT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YFOR_IN_STATEMENT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYForInStatementAccess().getItemYPropertyIDTerminalRuleCall_1_0_1(), semanticObject.eGet(LangPackage.Literals.YFOR_IN_STATEMENT__ITEM, false));
		feeder.accept(grammarAccess.getYForInStatementAccess().getCollectionYPropertyIDTerminalRuleCall_3_0_1(), semanticObject.eGet(LangPackage.Literals.YFOR_IN_STATEMENT__COLLECTION, false));
		feeder.accept(grammarAccess.getYForInStatementAccess().getBodyYBlockParserRuleCall_4_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YMember returns YFunction
	 *     YFunction returns YFunction
	 *     YNamedElement returns YFunction
	 *
	 * Constraint:
	 *     (
	 *         access=YAccessLevel? 
	 *         name=ValidID 
	 *         (params+=YParameter params+=YParameter*)? 
	 *         returnvalue?='->'? 
	 *         type=[YClass|QualifiedName]? 
	 *         body=YBlock
	 *     )
	 */
	protected void sequence_YFunction(ISerializationContext context, YFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YStatement returns YIfStatement
	 *     YIfStatement returns YIfStatement
	 *
	 * Constraint:
	 *     (expression=YOrExpression thenBlock=YBlock elseBlock=YBlock?)
	 */
	protected void sequence_YIfStatement(ISerializationContext context, YIfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YImport returns YImport
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_YImport(ISerializationContext context, YImport semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YIMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YIMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYImportAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YJoinDef returns YJoinDef
	 *
	 * Constraint:
	 *     (fromView=[YProperty|ID] relRef=[YAnnotRel|QualifiedName] toView=[YProperty|ID])
	 */
	protected void sequence_YJoinDef(ISerializationContext context, YJoinDef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YJOIN_DEF__FROM_VIEW) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YJOIN_DEF__FROM_VIEW));
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YJOIN_DEF__REL_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YJOIN_DEF__REL_REF));
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YJOIN_DEF__TO_VIEW) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YJOIN_DEF__TO_VIEW));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYJoinDefAccess().getFromViewYPropertyIDTerminalRuleCall_0_0_1(), semanticObject.eGet(LangPackage.Literals.YJOIN_DEF__FROM_VIEW, false));
		feeder.accept(grammarAccess.getYJoinDefAccess().getRelRefYAnnotRelQualifiedNameParserRuleCall_2_0_1(), semanticObject.eGet(LangPackage.Literals.YJOIN_DEF__REL_REF, false));
		feeder.accept(grammarAccess.getYJoinDefAccess().getToViewYPropertyIDTerminalRuleCall_4_0_1(), semanticObject.eGet(LangPackage.Literals.YJOIN_DEF__TO_VIEW, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YJoin returns YJoin
	 *
	 * Constraint:
	 *     (joindefs+=YJoinDef joindefs+=YJoinDef*)
	 */
	protected void sequence_YJoin(ISerializationContext context, YJoin semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YOrExpression returns YMulOrDiv
	 *     YOrExpression.YOrExpression_1_0 returns YMulOrDiv
	 *     YAndExpression returns YMulOrDiv
	 *     YAndExpression.YAndExpression_1_0 returns YMulOrDiv
	 *     YEqualityExpression returns YMulOrDiv
	 *     YEqualityExpression.YEqualityExpression_1_0 returns YMulOrDiv
	 *     YComparisonExpression returns YMulOrDiv
	 *     YComparisonExpression.YComparisonExpression_1_0 returns YMulOrDiv
	 *     YAdditiveExpression returns YMulOrDiv
	 *     YAdditiveExpression.YPlus_1_0_0_0 returns YMulOrDiv
	 *     YAdditiveExpression.YMinus_1_0_1_0 returns YMulOrDiv
	 *     YMultiplicativeExpression returns YMulOrDiv
	 *     YMultiplicativeExpression.YMulOrDiv_1_0 returns YMulOrDiv
	 *
	 * Constraint:
	 *     (left=YMultiplicativeExpression_YMulOrDiv_1_0 (op='*' | op='/') right=YPrimary)
	 */
	protected void sequence_YMultiplicativeExpression(ISerializationContext context, YMulOrDiv semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YOrExpression returns YOrExpression
	 *     YOrExpression.YOrExpression_1_0 returns YOrExpression
	 *
	 * Constraint:
	 *     (left=YOrExpression_YOrExpression_1_0 right=YAndExpression)
	 */
	protected void sequence_YOrExpression(ISerializationContext context, YOrExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YOR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YOR_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YOR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YOR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYOrExpressionAccess().getYOrExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getYOrExpressionAccess().getRightYAndExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YOrExpression returns YNot
	 *     YOrExpression.YOrExpression_1_0 returns YNot
	 *     YAndExpression returns YNot
	 *     YAndExpression.YAndExpression_1_0 returns YNot
	 *     YEqualityExpression returns YNot
	 *     YEqualityExpression.YEqualityExpression_1_0 returns YNot
	 *     YComparisonExpression returns YNot
	 *     YComparisonExpression.YComparisonExpression_1_0 returns YNot
	 *     YAdditiveExpression returns YNot
	 *     YAdditiveExpression.YPlus_1_0_0_0 returns YNot
	 *     YAdditiveExpression.YMinus_1_0_1_0 returns YNot
	 *     YMultiplicativeExpression returns YNot
	 *     YMultiplicativeExpression.YMulOrDiv_1_0 returns YNot
	 *     YPrimary returns YNot
	 *
	 * Constraint:
	 *     expression=YPrimary
	 */
	protected void sequence_YPrimary(ISerializationContext context, YNot semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YNOT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YNOT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYPrimaryAccess().getExpressionYPrimaryParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YOrExpression returns YParenties
	 *     YOrExpression.YOrExpression_1_0 returns YParenties
	 *     YAndExpression returns YParenties
	 *     YAndExpression.YAndExpression_1_0 returns YParenties
	 *     YEqualityExpression returns YParenties
	 *     YEqualityExpression.YEqualityExpression_1_0 returns YParenties
	 *     YComparisonExpression returns YParenties
	 *     YComparisonExpression.YComparisonExpression_1_0 returns YParenties
	 *     YAdditiveExpression returns YParenties
	 *     YAdditiveExpression.YPlus_1_0_0_0 returns YParenties
	 *     YAdditiveExpression.YMinus_1_0_1_0 returns YParenties
	 *     YMultiplicativeExpression returns YParenties
	 *     YMultiplicativeExpression.YMulOrDiv_1_0 returns YParenties
	 *     YPrimary returns YParenties
	 *
	 * Constraint:
	 *     a=YOrExpression
	 */
	protected void sequence_YPrimary(ISerializationContext context, YParenties semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YPARENTIES__A) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YPARENTIES__A));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYPrimaryAccess().getAYOrExpressionParserRuleCall_0_2_0(), semanticObject.getA());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YMember returns YProperty
	 *     YProperty returns YProperty
	 *     YNamedElement returns YProperty
	 *
	 * Constraint:
	 *     (
	 *         access=YAccessLevel? 
	 *         name=ValidID 
	 *         type=[YClass|QualifiedName] 
	 *         tuples=YTuples? 
	 *         optional?='?'? 
	 *         attrRef=[YAnnotAttr|QualifiedName]? 
	 *         annotations+=YAnnot*
	 *     )
	 */
	protected void sequence_YProperty_YTypedDeclaration(ISerializationContext context, YProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YStatement returns YReadEachStatement
	 *     YReadEachStatement returns YReadEachStatement
	 *
	 * Constraint:
	 *     (
	 *         structs+=YStructRefPair 
	 *         structs+=YStructRefPair* 
	 *         joinclause=YJoin? 
	 *         whereclause=YWhere? 
	 *         target=[YProperty|ID] 
	 *         success=YBlock
	 *     )
	 */
	protected void sequence_YReadEachStatement(ISerializationContext context, YReadEachStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YStatement returns YReadStatement
	 *     YReadStatement returns YReadStatement
	 *
	 * Constraint:
	 *     (
	 *         structs+=YStructRefPair 
	 *         structs+=YStructRefPair* 
	 *         joinclause=YJoin? 
	 *         whereclause=YWhere? 
	 *         success=YBlock 
	 *         notfound=YBlock
	 *     )
	 */
	protected void sequence_YReadStatement(ISerializationContext context, YReadStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YStatement returns YRepeatWhileStatement
	 *     YRepeatWhileStatement returns YRepeatWhileStatement
	 *
	 * Constraint:
	 *     (body=YBlock expression=YOrExpression)
	 */
	protected void sequence_YRepeatWhileStatement(ISerializationContext context, YRepeatWhileStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YREPEAT_WHILE_STATEMENT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YREPEAT_WHILE_STATEMENT__BODY));
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YREPEAT_WHILE_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YREPEAT_WHILE_STATEMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYRepeatWhileStatementAccess().getBodyYBlockParserRuleCall_1_0(), semanticObject.getBody());
		feeder.accept(grammarAccess.getYRepeatWhileStatementAccess().getExpressionYOrExpressionParserRuleCall_4_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YStatement returns YReturn
	 *     YReturn returns YReturn
	 *
	 * Constraint:
	 *     expression=YOrExpression?
	 */
	protected void sequence_YReturn(ISerializationContext context, YReturn semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YStatement returns YMemberSelection
	 *     YExpression returns YMemberSelection
	 *     YAssignment returns YMemberSelection
	 *     YAssignment.YAssignment_1_0 returns YMemberSelection
	 *     YSelectionExpression returns YMemberSelection
	 *     YSelectionExpression.YMemberSelection_1_0 returns YMemberSelection
	 *     YOrExpression returns YMemberSelection
	 *     YOrExpression.YOrExpression_1_0 returns YMemberSelection
	 *     YAndExpression returns YMemberSelection
	 *     YAndExpression.YAndExpression_1_0 returns YMemberSelection
	 *     YEqualityExpression returns YMemberSelection
	 *     YEqualityExpression.YEqualityExpression_1_0 returns YMemberSelection
	 *     YComparisonExpression returns YMemberSelection
	 *     YComparisonExpression.YComparisonExpression_1_0 returns YMemberSelection
	 *     YAdditiveExpression returns YMemberSelection
	 *     YAdditiveExpression.YPlus_1_0_0_0 returns YMemberSelection
	 *     YAdditiveExpression.YMinus_1_0_1_0 returns YMemberSelection
	 *     YMultiplicativeExpression returns YMemberSelection
	 *     YMultiplicativeExpression.YMulOrDiv_1_0 returns YMemberSelection
	 *     YPrimary returns YMemberSelection
	 *
	 * Constraint:
	 *     (receiver=YSelectionExpression_YMemberSelection_1_0 member=[YMember|ID] (functioninvocation?='(' (args+=YOrExpression args+=YOrExpression*)?)?)
	 */
	protected void sequence_YSelectionExpression(ISerializationContext context, YMemberSelection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YStructRefPair returns YStructRefPair
	 *
	 * Constraint:
	 *     (structproperty=[YProperty|ID] structclass=[YAnnotEntity|ID])
	 */
	protected void sequence_YStructRefPair(ISerializationContext context, YStructRefPair semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YSTRUCT_REF_PAIR__STRUCTPROPERTY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YSTRUCT_REF_PAIR__STRUCTPROPERTY));
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YSTRUCT_REF_PAIR__STRUCTCLASS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YSTRUCT_REF_PAIR__STRUCTCLASS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYStructRefPairAccess().getStructpropertyYPropertyIDTerminalRuleCall_0_0_1(), semanticObject.eGet(LangPackage.Literals.YSTRUCT_REF_PAIR__STRUCTPROPERTY, false));
		feeder.accept(grammarAccess.getYStructRefPairAccess().getStructclassYAnnotEntityIDTerminalRuleCall_2_0_1(), semanticObject.eGet(LangPackage.Literals.YSTRUCT_REF_PAIR__STRUCTCLASS, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YSwitchCase returns YSwitchCase
	 *
	 * Constraint:
	 *     (caseExpression=YExpression? then=YBlock)
	 */
	protected void sequence_YSwitchCase(ISerializationContext context, YSwitchCase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YStatement returns YSwitchStatement
	 *     YSwitchStatement returns YSwitchStatement
	 *
	 * Constraint:
	 *     (switchExpression=YExpression cases+=YSwitchCase* default=YBlock?)
	 */
	protected void sequence_YSwitchStatement(ISerializationContext context, YSwitchStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YStatement returns YBoolConstant
	 *     YExpression returns YBoolConstant
	 *     YAssignment returns YBoolConstant
	 *     YAssignment.YAssignment_1_0 returns YBoolConstant
	 *     YSelectionExpression returns YBoolConstant
	 *     YSelectionExpression.YMemberSelection_1_0 returns YBoolConstant
	 *     YOrExpression returns YBoolConstant
	 *     YOrExpression.YOrExpression_1_0 returns YBoolConstant
	 *     YAndExpression returns YBoolConstant
	 *     YAndExpression.YAndExpression_1_0 returns YBoolConstant
	 *     YEqualityExpression returns YBoolConstant
	 *     YEqualityExpression.YEqualityExpression_1_0 returns YBoolConstant
	 *     YComparisonExpression returns YBoolConstant
	 *     YComparisonExpression.YComparisonExpression_1_0 returns YBoolConstant
	 *     YAdditiveExpression returns YBoolConstant
	 *     YAdditiveExpression.YPlus_1_0_0_0 returns YBoolConstant
	 *     YAdditiveExpression.YMinus_1_0_1_0 returns YBoolConstant
	 *     YMultiplicativeExpression returns YBoolConstant
	 *     YMultiplicativeExpression.YMulOrDiv_1_0 returns YBoolConstant
	 *     YPrimary returns YBoolConstant
	 *     YTerminalExpression returns YBoolConstant
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_YTerminalExpression(ISerializationContext context, YBoolConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YStatement returns YIntConstant
	 *     YExpression returns YIntConstant
	 *     YAssignment returns YIntConstant
	 *     YAssignment.YAssignment_1_0 returns YIntConstant
	 *     YSelectionExpression returns YIntConstant
	 *     YSelectionExpression.YMemberSelection_1_0 returns YIntConstant
	 *     YOrExpression returns YIntConstant
	 *     YOrExpression.YOrExpression_1_0 returns YIntConstant
	 *     YAndExpression returns YIntConstant
	 *     YAndExpression.YAndExpression_1_0 returns YIntConstant
	 *     YEqualityExpression returns YIntConstant
	 *     YEqualityExpression.YEqualityExpression_1_0 returns YIntConstant
	 *     YComparisonExpression returns YIntConstant
	 *     YComparisonExpression.YComparisonExpression_1_0 returns YIntConstant
	 *     YAdditiveExpression returns YIntConstant
	 *     YAdditiveExpression.YPlus_1_0_0_0 returns YIntConstant
	 *     YAdditiveExpression.YMinus_1_0_1_0 returns YIntConstant
	 *     YMultiplicativeExpression returns YIntConstant
	 *     YMultiplicativeExpression.YMulOrDiv_1_0 returns YIntConstant
	 *     YPrimary returns YIntConstant
	 *     YTerminalExpression returns YIntConstant
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_YTerminalExpression(ISerializationContext context, YIntConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YINT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YINT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYTerminalExpressionAccess().getValueINTTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YStatement returns YNew
	 *     YExpression returns YNew
	 *     YAssignment returns YNew
	 *     YAssignment.YAssignment_1_0 returns YNew
	 *     YSelectionExpression returns YNew
	 *     YSelectionExpression.YMemberSelection_1_0 returns YNew
	 *     YOrExpression returns YNew
	 *     YOrExpression.YOrExpression_1_0 returns YNew
	 *     YAndExpression returns YNew
	 *     YAndExpression.YAndExpression_1_0 returns YNew
	 *     YEqualityExpression returns YNew
	 *     YEqualityExpression.YEqualityExpression_1_0 returns YNew
	 *     YComparisonExpression returns YNew
	 *     YComparisonExpression.YComparisonExpression_1_0 returns YNew
	 *     YAdditiveExpression returns YNew
	 *     YAdditiveExpression.YPlus_1_0_0_0 returns YNew
	 *     YAdditiveExpression.YMinus_1_0_1_0 returns YNew
	 *     YMultiplicativeExpression returns YNew
	 *     YMultiplicativeExpression.YMulOrDiv_1_0 returns YNew
	 *     YPrimary returns YNew
	 *     YTerminalExpression returns YNew
	 *
	 * Constraint:
	 *     (type=[YClass|QualifiedName] (arguments+=YOrExpression arguments+=YOrExpression*)?)
	 */
	protected void sequence_YTerminalExpression(ISerializationContext context, YNew semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YStatement returns YNull
	 *     YExpression returns YNull
	 *     YAssignment returns YNull
	 *     YAssignment.YAssignment_1_0 returns YNull
	 *     YSelectionExpression returns YNull
	 *     YSelectionExpression.YMemberSelection_1_0 returns YNull
	 *     YOrExpression returns YNull
	 *     YOrExpression.YOrExpression_1_0 returns YNull
	 *     YAndExpression returns YNull
	 *     YAndExpression.YAndExpression_1_0 returns YNull
	 *     YEqualityExpression returns YNull
	 *     YEqualityExpression.YEqualityExpression_1_0 returns YNull
	 *     YComparisonExpression returns YNull
	 *     YComparisonExpression.YComparisonExpression_1_0 returns YNull
	 *     YAdditiveExpression returns YNull
	 *     YAdditiveExpression.YPlus_1_0_0_0 returns YNull
	 *     YAdditiveExpression.YMinus_1_0_1_0 returns YNull
	 *     YMultiplicativeExpression returns YNull
	 *     YMultiplicativeExpression.YMulOrDiv_1_0 returns YNull
	 *     YPrimary returns YNull
	 *     YTerminalExpression returns YNull
	 *
	 * Constraint:
	 *     {YNull}
	 */
	protected void sequence_YTerminalExpression(ISerializationContext context, YNull semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YStatement returns YSelf
	 *     YExpression returns YSelf
	 *     YAssignment returns YSelf
	 *     YAssignment.YAssignment_1_0 returns YSelf
	 *     YSelectionExpression returns YSelf
	 *     YSelectionExpression.YMemberSelection_1_0 returns YSelf
	 *     YOrExpression returns YSelf
	 *     YOrExpression.YOrExpression_1_0 returns YSelf
	 *     YAndExpression returns YSelf
	 *     YAndExpression.YAndExpression_1_0 returns YSelf
	 *     YEqualityExpression returns YSelf
	 *     YEqualityExpression.YEqualityExpression_1_0 returns YSelf
	 *     YComparisonExpression returns YSelf
	 *     YComparisonExpression.YComparisonExpression_1_0 returns YSelf
	 *     YAdditiveExpression returns YSelf
	 *     YAdditiveExpression.YPlus_1_0_0_0 returns YSelf
	 *     YAdditiveExpression.YMinus_1_0_1_0 returns YSelf
	 *     YMultiplicativeExpression returns YSelf
	 *     YMultiplicativeExpression.YMulOrDiv_1_0 returns YSelf
	 *     YPrimary returns YSelf
	 *     YTerminalExpression returns YSelf
	 *
	 * Constraint:
	 *     {YSelf}
	 */
	protected void sequence_YTerminalExpression(ISerializationContext context, YSelf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YStatement returns YStringConstant
	 *     YExpression returns YStringConstant
	 *     YAssignment returns YStringConstant
	 *     YAssignment.YAssignment_1_0 returns YStringConstant
	 *     YSelectionExpression returns YStringConstant
	 *     YSelectionExpression.YMemberSelection_1_0 returns YStringConstant
	 *     YOrExpression returns YStringConstant
	 *     YOrExpression.YOrExpression_1_0 returns YStringConstant
	 *     YAndExpression returns YStringConstant
	 *     YAndExpression.YAndExpression_1_0 returns YStringConstant
	 *     YEqualityExpression returns YStringConstant
	 *     YEqualityExpression.YEqualityExpression_1_0 returns YStringConstant
	 *     YComparisonExpression returns YStringConstant
	 *     YComparisonExpression.YComparisonExpression_1_0 returns YStringConstant
	 *     YAdditiveExpression returns YStringConstant
	 *     YAdditiveExpression.YPlus_1_0_0_0 returns YStringConstant
	 *     YAdditiveExpression.YMinus_1_0_1_0 returns YStringConstant
	 *     YMultiplicativeExpression returns YStringConstant
	 *     YMultiplicativeExpression.YMulOrDiv_1_0 returns YStringConstant
	 *     YPrimary returns YStringConstant
	 *     YTerminalExpression returns YStringConstant
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_YTerminalExpression(ISerializationContext context, YStringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YSTRING_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YSTRING_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYTerminalExpressionAccess().getValueSTRINGTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YStatement returns YSuper
	 *     YExpression returns YSuper
	 *     YAssignment returns YSuper
	 *     YAssignment.YAssignment_1_0 returns YSuper
	 *     YSelectionExpression returns YSuper
	 *     YSelectionExpression.YMemberSelection_1_0 returns YSuper
	 *     YOrExpression returns YSuper
	 *     YOrExpression.YOrExpression_1_0 returns YSuper
	 *     YAndExpression returns YSuper
	 *     YAndExpression.YAndExpression_1_0 returns YSuper
	 *     YEqualityExpression returns YSuper
	 *     YEqualityExpression.YEqualityExpression_1_0 returns YSuper
	 *     YComparisonExpression returns YSuper
	 *     YComparisonExpression.YComparisonExpression_1_0 returns YSuper
	 *     YAdditiveExpression returns YSuper
	 *     YAdditiveExpression.YPlus_1_0_0_0 returns YSuper
	 *     YAdditiveExpression.YMinus_1_0_1_0 returns YSuper
	 *     YMultiplicativeExpression returns YSuper
	 *     YMultiplicativeExpression.YMulOrDiv_1_0 returns YSuper
	 *     YPrimary returns YSuper
	 *     YTerminalExpression returns YSuper
	 *
	 * Constraint:
	 *     {YSuper}
	 */
	protected void sequence_YTerminalExpression(ISerializationContext context, YSuper semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YStatement returns YSymbolRef
	 *     YExpression returns YSymbolRef
	 *     YAssignment returns YSymbolRef
	 *     YAssignment.YAssignment_1_0 returns YSymbolRef
	 *     YSelectionExpression returns YSymbolRef
	 *     YSelectionExpression.YMemberSelection_1_0 returns YSymbolRef
	 *     YOrExpression returns YSymbolRef
	 *     YOrExpression.YOrExpression_1_0 returns YSymbolRef
	 *     YAndExpression returns YSymbolRef
	 *     YAndExpression.YAndExpression_1_0 returns YSymbolRef
	 *     YEqualityExpression returns YSymbolRef
	 *     YEqualityExpression.YEqualityExpression_1_0 returns YSymbolRef
	 *     YComparisonExpression returns YSymbolRef
	 *     YComparisonExpression.YComparisonExpression_1_0 returns YSymbolRef
	 *     YAdditiveExpression returns YSymbolRef
	 *     YAdditiveExpression.YPlus_1_0_0_0 returns YSymbolRef
	 *     YAdditiveExpression.YMinus_1_0_1_0 returns YSymbolRef
	 *     YMultiplicativeExpression returns YSymbolRef
	 *     YMultiplicativeExpression.YMulOrDiv_1_0 returns YSymbolRef
	 *     YPrimary returns YSymbolRef
	 *     YTerminalExpression returns YSymbolRef
	 *
	 * Constraint:
	 *     symbol=[YSymbol|ID]
	 */
	protected void sequence_YTerminalExpression(ISerializationContext context, YSymbolRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YSYMBOL_REF__SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YSYMBOL_REF__SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYTerminalExpressionAccess().getSymbolYSymbolIDTerminalRuleCall_6_1_0_1(), semanticObject.eGet(LangPackage.Literals.YSYMBOL_REF__SYMBOL, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YTuples returns YTuples
	 *
	 * Constraint:
	 *     (includes+=[YProperty|ID] includes+=[YProperty|ID]*)?
	 */
	protected void sequence_YTuples(ISerializationContext context, YTuples semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YParameter returns YParameter
	 *     YSymbol returns YParameter
	 *     YNamedElement returns YParameter
	 *
	 * Constraint:
	 *     (name=ValidID type=[YClass|QualifiedName])
	 */
	protected void sequence_YTypedDeclaration(ISerializationContext context, YParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YNAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YNAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YSYMBOL__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YSYMBOL__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYTypedDeclarationAccess().getNameValidIDParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getYTypedDeclarationAccess().getTypeYClassQualifiedNameParserRuleCall_2_0_1(), semanticObject.eGet(LangPackage.Literals.YSYMBOL__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YStatement returns YVariableDeclaration
	 *     YVariableDeclaration returns YVariableDeclaration
	 *     YSymbol returns YVariableDeclaration
	 *     YNamedElement returns YVariableDeclaration
	 *
	 * Constraint:
	 *     (name=ValidID type=[YClass|QualifiedName] expression=YOrExpression)
	 */
	protected void sequence_YTypedDeclaration_YVariableDeclaration(ISerializationContext context, YVariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YNAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YNAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YSYMBOL__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YSYMBOL__TYPE));
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YVARIABLE_DECLARATION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YVARIABLE_DECLARATION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYTypedDeclarationAccess().getNameValidIDParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getYTypedDeclarationAccess().getTypeYClassQualifiedNameParserRuleCall_2_0_1(), semanticObject.eGet(LangPackage.Literals.YSYMBOL__TYPE, false));
		feeder.accept(grammarAccess.getYVariableDeclarationAccess().getExpressionYOrExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YStatement returns YUpdateStatement
	 *     YUpdateStatement returns YUpdateStatement
	 *
	 * Constraint:
	 *     (struct=YStructRefPair setBlock=YBlock success=YBlock)
	 */
	protected void sequence_YUpdateStatement(ISerializationContext context, YUpdateStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YUPDATE_STATEMENT__STRUCT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YUPDATE_STATEMENT__STRUCT));
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YUPDATE_STATEMENT__SET_BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YUPDATE_STATEMENT__SET_BLOCK));
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YUPDATE_STATEMENT__SUCCESS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YUPDATE_STATEMENT__SUCCESS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYUpdateStatementAccess().getStructYStructRefPairParserRuleCall_1_0(), semanticObject.getStruct());
		feeder.accept(grammarAccess.getYUpdateStatementAccess().getSetBlockYBlockParserRuleCall_2_0(), semanticObject.getSetBlock());
		feeder.accept(grammarAccess.getYUpdateStatementAccess().getSuccessYBlockParserRuleCall_4_0(), semanticObject.getSuccess());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YWhere returns YWhere
	 *
	 * Constraint:
	 *     expression=YOrExpression
	 */
	protected void sequence_YWhere(ISerializationContext context, YWhere semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YWHERE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YWHERE__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYWhereAccess().getExpressionYOrExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YStatement returns YWhileStatement
	 *     YWhileStatement returns YWhileStatement
	 *
	 * Constraint:
	 *     (expression=YOrExpression body=YBlock)
	 */
	protected void sequence_YWhileStatement(ISerializationContext context, YWhileStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YWHILE_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YWHILE_STATEMENT__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, LangPackage.Literals.YWHILE_STATEMENT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangPackage.Literals.YWHILE_STATEMENT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYWhileStatementAccess().getExpressionYOrExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getYWhileStatementAccess().getBodyYBlockParserRuleCall_4_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YWidget returns YWidget
	 *
	 * Constraint:
	 *     (
	 *         (name=QualifiedName ((imports+=YImport+ classes+=YClass+) | classes+=YClass+)) | 
	 *         (((name=QualifiedName imports+=YImport+) | imports+=YImport+)? annotations+=YAnnotTop+ classes+=YClass+) | 
	 *         (imports+=YImport+ classes+=YClass+) | 
	 *         classes+=YClass+
	 *     )?
	 */
	protected void sequence_YWidget(ISerializationContext context, YWidget semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
