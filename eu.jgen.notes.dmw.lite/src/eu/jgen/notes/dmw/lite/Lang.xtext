/**
 * [The "BSD license"]
 * Copyright (c) 2016, JGen Notes
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions 
 *    and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions 
 *    and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */
grammar eu.jgen.notes.dmw.lite.Lang with org.eclipse.xtext.xbase.Xbase
//grammar eu.jgen.notes.dmw.lite.Lang with org.eclipse.xtext.xbase.annotations.XbaseWithAnnotations
generate lang "http://www.jgen.eu/notes/dmw/lite/Lang"

import "http://www.eclipse.org/xtext/xbase/Xbase" as xbase
import "http://www.eclipse.org/xtext/xbase/Xtype" as xtype
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as types
 

YWidget:
	{YWidget} package=YPackageDeclaration  
	importSection=XImportSection?
	annotations+=YAnnotTop*
	classes+=YClass*;
	
YPackageDeclaration:
	{YPackageDeclaration} 'package' name=QualifiedName;


enum YAccessLevel:
	PRIVATE='private' | PROTECTED='protected' | PUBLIC='public';

YArgumentValue:
	INT | STRING;

YClass:
	{YClass} 'class' name=ValidID (':' superclass=JvmTypeReference)? ('->' entityRef=[YAnnotEntity|QualifiedName])?
	'{'
	members+=YMember*
	'}';

YMember:
	YClass | YProperty | YFunction;


YProperty:
	access=YAccessLevel? 'var' name=ValidID ':' type=JvmTypeReference tuples=YTuples? (optional?='?')? ('->' attrRef=[YAnnotAttr|QualifiedName])?
	annotations+=YAnnot* ';';

YTuples:
	{YTuples} '<' (includes+=[YProperty] (',' includes+=[YProperty])*)? '>';

YFunction:
	access=YAccessLevel? 'func' name=ValidID
	'(' (params+=JvmTypeReference (',' params+=JvmTypeReference)*)? ')' ('->' type=JvmTypeReference)?
	body=XBlockExpression;

YReadStatement returns XExpression:
	{YReadStatement} 'db-read' structs+=YStructRefPair (',' structs+=YStructRefPair)* 
	joinclause=YJoin? 
	('where' whereclause=XExpression)?
	'success' '{'
    successExpressions += XExpression*
	'}' 'not' 'found' '{' 
	notfoundExpressions += XExpression*
	'}';

YReadEachStatement:
	'readeach' structs+=YStructRefPair (',' structs+=YStructRefPair)* joinclause=YJoin? whereclause=XExpression?
	'target' target=[YProperty]
	success=XBlockExpression;

YCreateStatement returns XExpression:
	{YCreateStatement} 'db-create' struct=YStructRefPair '{'
	setExpressions += XExpression*
	'}' 'success' '{'
    successExpressions += XExpression*
    '}' 'already' 'exist' '{' 
	alreadyExistExpressions += XExpression*
	'}';

YUpdateStatement:
	'update' struct=YStructRefPair
	setBlock=XBlockExpression
	'success' success=XBlockExpression;

YDeleteStatement:
	'delete' struct=YStructRefPair ';';

YAssociateStatement:
	'associate' joinref=YJoinDef ';';

YStructRefPair:
	structproperty=[YProperty] '->' structclass=[YAnnotEntity];

YJoin:
	{YJoin} 'join' joindefs+=YJoinDef ("," joindefs+=YJoinDef)*;

YJoinDef:
	fromView=[YProperty] '->' relRef=[YAnnotRel|QualifiedName] '->' toView=[YProperty];

YWhere returns XExpression:
	{YWhere} 'where' expression=XExpression;

/*
 * Predefined annotations
 */
YAnnot:
	{YAnnot} type=(YAnnotLength | YAnnotDecimal | YAnnotAction | YAnnotMessage | YAnnotMsgType | YAnnotDefault | YAnnotMax);

YAnnotTop:
	type=(YAnnotEntity | YAnnotTechnicalDesign | YAnnotSwift | YAnnotJava | YAnnotDatabase);

YAnnotLength returns YAnnot:
	{YAnnotLength} '@length' '(' length=INT ')';
	
YAnnotMax returns YAnnot:
	{YAnnotMax} '@max' '(' length=INT ')';

YAnnotDecimal returns YAnnot:
	{YAnnotDecimal} '@decimal' '(' length=INT ',' decimal=INT ')';
	
YAnnotDefault returns YAnnot:
	{YAnnotDefault} '@default' '('type=YAnnotDefaultType')';
	
YAnnotDefaultType:
	 YAnnotDefaultText | YAnnotDefaultNumber
;

YAnnotDefaultText:
	value=STRING
;

YAnnotDefaultNumber:
	value=INT
;

YAnnotAction returns YAnnot:
	{YAnnotAction} '@action' '(' action=ValidID ')';

YAnnotMessage returns YAnnot:
	{YAnnotMessage} '@message' '(' msg=STRING ')';

YAnnotMsgType returns YAnnot:
	'@msgtype' '(' msgtype=ValidID ')';

YAnnotEntityInner:
	YAnnotAttr | YAnnotRel | YAnnotId;

YAnnotEntity:
	'@entity' name=ValidID (':' superannot=[YAnnotEntity|QualifiedName])? '{'
	annots+=YAnnotEntityInner*
	'}';

YAnnotAttr:
	{YAnnotAttr} '@attr' name=ValidID ':' yclass=JvmTypeReference (optional='?')? annots+=YAnnot* ';'?;

YAnnotRel:
	{YAnnotRel} '@rel' (parent?='@parent')? name=ValidID (optional?='?')? '->' target=[YAnnotEntity|QualifiedName]
	(many?='*')? ('<-'
	inverse=[YAnnotRel|QualifiedName])? ';'?;

YAnnotIdInner:
	YAnnotAttr | YAnnotRel;

YAnnotId:
	{YAnnotId} '@id' name=ValidID '(' annots+=[YAnnotEntityInner] (',' annots+=[YAnnotEntityInner])* ')' ';'?;

/*
 * Start Technical design
 */
YAnnotTechnicalDesign:
	{YAnnotTechnicalDesign} '@td' 'database' database=[YAnnotDatabase] '{'
	features+=YAnnotTable*
	'}';

YAnnotTable:
	{YAnnotTable} '@table' name=ValidID '->' entityref=[YAnnotEntity|QualifiedName] '{'
	columns+=YAnnotAbstractColumn*
	primarykey=YAnnotPrimaryKey?
	foreignkeys+=YAnnotForeignKey*
	'}';

YAnnotColumn:
	{YAnnotColumn} '->' attrref=[YAnnotAttr|QualifiedName]
	'as' type=('VARCHAR' | 'CHAR' | 'INTEGER' | 'BIGINT' | 'SMALLINT' | 'DECIMAL' | 'TIME' | 'DATE' | 'TIMESTAMP' |
	'BOOLEAN')
	(optional='?')? annots+=(YAnnotLength | YAnnotDecimal)* ';'?;

YAnnotColumnLike:
	{YAnnotColumnLike} '->' columnref=[YAnnotAbstractColumn|QualifiedName] ';'?;

YAnnotAbstractColumn:
	{YAnnotAbstractColumn} '@column' name=ValidID type=(YAnnotColumn | YAnnotColumnLike);

YAnnotPrimaryKey:
	{YAnnotPrimaryKey} '@primary' '(' columns+=[YAnnotAbstractColumn]* (',' columns+=[YAnnotAbstractColumn])* ')' ';'?;

YAnnotForeignKey:
	{YAnnotForeignKey} '@foreign' relationship=[YAnnotRel|QualifiedName] '{'
	columns+=YAnnotAbstractColumn (',' columns+=YAnnotAbstractColumn)*
	'}' ';'?;

/*
 * Swift Generation Annotations
 */
YAnnotJava:
	{YAnnotJava} '@java' ('uses' database=[YAnnotDatabase])? ';'?;

/*
 * Swift Generation Annotations
 */
YAnnotSwift:
	{YAnnotSwift} '@swift' 'module' name=ValidID ('uses' database=[YAnnotDatabase])? ';'?;

/*
 * Database Generation Annotations
 */
YAnnotDatabase:
	{YAnnotDatabase} '@database' name=ValidID ';'?;
 
@Override 
XPrimaryExpression returns xbase::XExpression:
	YReadStatement |
	YCreateStatement |
	YDeleteStatement |
	YUpdateStatement |
	YReadEachStatement |
	super
	;

/*
 * Database Generation Annotations
 */
 
DBExpression returns DBExpression :
	'where' DBOrExpression;

DBOrExpression returns DBExpression:
	DBAndExpression (=>({DBBinaryOperation.leftOperand=current} feature=[types::JvmIdentifiableElement|OpOr]) rightOperand=DBAndExpression)*;


DBAndExpression returns DBExpression:
	DBEqualityExpression (=>({DBBinaryOperation.leftOperand=current} feature=[types::JvmIdentifiableElement|OpAnd]) rightOperand=DBEqualityExpression)*;


DBEqualityExpression returns DBExpression:
	DBRelationalExpression (=>({DBBinaryOperation.leftOperand=current} feature=[types::JvmIdentifiableElement|OpEquality])
	rightOperand=DBRelationalExpression)*;

DBRelationalExpression returns DBExpression:
	leftOperand=[types::JvmIdentifiableElement|OpCompare] rightOperand=[types::JvmIdentifiableElement|OpCompare];
	 
	